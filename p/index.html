<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ï¼“ãƒãƒƒãƒãƒ‘ã‚ºãƒ«</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* style.css ã®å†…å®¹ã‚’ã“ã“ã«ç›´æ¥è¨˜è¿° */
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: 'Inter', sans-serif; /* ãƒ•ã‚©ãƒ³ãƒˆã‚’Interã«è¨­å®š */
            color: #333;
            overflow: hidden; /* ã‚¹ãƒãƒ›ã§ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«é˜²æ­¢ */
        }

        h1 {
            margin-bottom: 20px;
            color: #4a4a4a;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        #time-bar-container {
            width: 90%; /* ç”»é¢å¹…ã®90% */
            max-width: 600px; /* æœ€å¤§å¹…ã‚’è¨­å®š */
            height: 20px;
            background-color: #ccc;
            border-radius: 10px;
            margin-bottom: 15px;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
        }

        #time-bar-fill {
            height: 100%;
            width: 100%; /* åˆæœŸã¯100% */
            background-color: #4CAF50; /* ç·‘è‰² */
            border-radius: 10px;
            transition: width 0.9s linear; /* æ»‘ã‚‰ã‹ãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
            transform-origin: right; /* å³ã‹ã‚‰å·¦ã«ç¸®ã‚€ */
        }

        #game-container {
            border: 4px solid #8B4513; /* æœ¨ç›®èª¿ã®æ  */
            background-color: #fff;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            border-radius: 15px; /* è§’ã‚’ä¸¸ã */
            padding: 10px; /* å†…å´ã®ä½™ç™½ */
            position: relative; /* é¸æŠãƒã‚¤ãƒ©ã‚¤ãƒˆç”¨ */

            /* Canvasã‚’ä¸­å¤®ã«é…ç½®ã™ã‚‹ãŸã‚ã®Flexboxè¨­å®šã‚’è¿½åŠ  */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background-color: #eee; /* ã‚¿ã‚¤ãƒ«ãŒãªã„éƒ¨åˆ†ã®èƒŒæ™¯è‰² */
            border-radius: 10px; /* Canvasè‡ªä½“ã‚‚è§’ã‚’ä¸¸ã */
            /* æºã‚Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³ã¯JavaScriptã§åˆ¶å¾¡ã™ã‚‹ãŸã‚å‰Šé™¤ */
        }

        /* ãƒ‘ãƒãƒ«ãŒæºã‚Œã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®CSSã¯JavaScriptã§åˆ¶å¾¡ã™ã‚‹ãŸã‚å‰Šé™¤ */
        /* .shaking, @keyframes shake ã¯ä¸è¦ */


        /* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            z-index: 1000;
            display: none; /* åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º */
            text-align: center;
            font-size: 1.2em;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        #message-box button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }

        #message-box button:hover {
            background-color: #45a049;
        }

        /* ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #game-over-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            display: none; /* åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º */
        }

        #game-over-popup p {
            color: white;
            font-size: 3em;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            margin-bottom: 30px;
        }

        #game-over-popup button {
            background-color: #FF4500; /* OrangeRed */
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.5em;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: background-color 0.3s ease, transform 0.1s ease;
        }

        #game-over-popup button:hover {
            background-color: #CC3700;
            transform: translateY(-2px);
        }
        #game-over-popup button:active {
            transform: translateY(0);
        }

    </style>
</head>
<body>
    <h1>ï¼“ãƒãƒƒãƒãƒ‘ã‚ºãƒ«</h1>
    <div id="time-bar-container">
        <div id="time-bar-fill"></div>
    </div>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="message-box">
        <p id="message-text"></p>
        <button id="message-button">OK</button>
    </div>

    <div id="game-over-popup">
        <p id="game-over-text">GAME OVER</p>
        <button id="play-again-button">ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤</button>
    </div>

    <script>
        // script.js ã®å†…å®¹ã‚’ã“ã“ã«ç›´æ¥è¨˜è¿°
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageButton = document.getElementById('message-button');
        const gameContainer = document.getElementById('game-container');
        const timeBarFill = document.getElementById('time-bar-fill');
        const gameOverPopup = document.getElementById('game-over-popup');
        const playAgainButton = document.getElementById('play-again-button');

        let TILE_SIZE; // 1ã‚¿ã‚¤ãƒ«ã®ã‚µã‚¤ã‚º (px) - å‹•çš„ã«è¨ˆç®—ã•ã‚Œã‚‹
        const GRID_COLS = 8; // ã‚°ãƒªãƒƒãƒ‰ã®åˆ—æ•°
        const GRID_ROWS = 8; // ã‚°ãƒªãƒƒãƒ‰ã®è¡Œæ•°
        const ITEM_TYPES = 5; // ã‚¢ã‚¤ãƒ†ãƒ ã®ç¨®é¡æ•° (0-4ã®æ•°å€¤ã§è¡¨ç¾)
        const SWAP_ANIMATION_DURATION = 200; // å…¥ã‚Œæ›¿ãˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ™‚é–“ (ms)
        const MATCH_FADE_DURATION = 300; // ãƒãƒƒãƒæ¶ˆå»ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ™‚é–“ (ms)
        const DROP_ANIMATION_DURATION = 400; // è½ä¸‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ™‚é–“ (ms)
        
        const MAX_GAME_TIME = 60; // ã‚²ãƒ¼ãƒ ã®æœ€å¤§æ™‚é–“ (ç§’)
        const TIME_BONUS_PER_MATCH = 3; // 1ãƒãƒƒãƒã§å¢—ãˆã‚‹æ™‚é–“ (ç§’)
        const LOW_TIME_THRESHOLD_RATIO = 0.1; // ã‚¿ã‚¤ãƒ ãƒãƒ¼ãŒéœ‡ãˆå§‹ã‚ã‚‹å‰²åˆ (ä¾‹: 0.1 = 10%)

        let gameBoard = []; // ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹äºŒæ¬¡å…ƒé…åˆ—
        let selectedTile = null; // é¸æŠã•ã‚ŒãŸã‚¿ã‚¤ãƒ« {row, col}
        let isProcessing = false; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã‚„å‡¦ç†ä¸­ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
        let gameTime = MAX_GAME_TIME; // ç¾åœ¨ã®æ®‹ã‚Šæ™‚é–“
        let timeUpdateInterval = null; // setIntervalã®ID
        let isGameOver = false; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ©ã‚°
        let isShaking = false; // ãƒ‘ãƒãƒ«ãŒéœ‡ãˆã¦ã„ã‚‹ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°
        let shakeAnimationId = null; // æºã‚Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®requestAnimationFrame ID

        // å„ã‚¢ã‚¤ãƒ†ãƒ ã®çµµæ–‡å­—ã‚’å®šç¾©
        const fruitEmojis = [
            'ğŸ', // Apple
            'ğŸŒ', // Banana
            'ğŸ‡', // Grape
            'ğŸŠ', // Orange
            'ğŸ“'  // Strawberry
        ];

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•° (alertã®ä»£æ›¿)
        function showMessageBox(message) {
            messageText.textContent = message;
            messageBox.style.display = 'block';
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ã‚’éè¡¨ç¤ºã«ã™ã‚‹é–¢æ•°
        messageButton.addEventListener('click', () => {
            messageBox.style.display = 'none';
        });

        /**
         * Canvasã¨ã‚¿ã‚¤ãƒ«ã®ã‚µã‚¤ã‚ºã‚’ç”»é¢ã«åˆã‚ã›ã¦è¨ˆç®—ã—ã€è¨­å®šã—ã¾ã™ã€‚
         */
        function calculateCanvasSize() {
            // ç”»é¢ã®åˆ©ç”¨å¯èƒ½ãªå¹…ã¨é«˜ã•ã‹ã‚‰ã€ãƒœãƒ¼ãƒ‰ã®æœ€å¤§ã‚µã‚¤ã‚ºã‚’æ±ºå®š
            // å·¦å³ã«å°‘ã—ä½™ç™½ã‚’æŒãŸã›ã‚‹ãŸã‚ã€ç”»é¢å¹…ã®95%ã‚’ä½¿ç”¨
            const maxBoardWidth = window.innerWidth * 0.95;
            // ä¸Šä¸‹ã«ã‚‚ä½™ç™½ã‚’æŒãŸã›ã‚‹ãŸã‚ã€ç”»é¢é«˜ã•ã®80%ã‚’ä½¿ç”¨ (ãƒ˜ãƒƒãƒ€ãƒ¼ãªã©ã‚’è€ƒæ…®)
            const maxBoardHeight = window.innerHeight * 0.80;

            // 1ã‚¿ã‚¤ãƒ«ã‚ãŸã‚Šã®æœ€å¤§ã‚µã‚¤ã‚ºã‚’ã€å¹…ã¨é«˜ã•ã®ä¸¡æ–¹ã‹ã‚‰è¨ˆç®—
            const potentialTileSizeByWidth = Math.floor(maxBoardWidth / GRID_COLS);
            const potentialTileSizeByHeight = Math.floor(maxBoardHeight / GRID_ROWS);

            // ã©ã¡ã‚‰ã‹å°ã•ã„æ–¹ã‚’æ¡ç”¨ã—ã¦ã€ãƒœãƒ¼ãƒ‰å…¨ä½“ãŒç”»é¢å†…ã«åã¾ã‚‹ã‚ˆã†ã«ã™ã‚‹
            TILE_SIZE = Math.min(potentialTileSizeByWidth, potentialTileSizeByHeight);

            // ã‚¿ã‚¤ãƒ«ãŒå°ã•ããªã‚Šã™ããªã„ã‚ˆã†ã«æœ€å°ã‚µã‚¤ã‚ºã‚’è¨­å®š (ä¾‹: 30px)
            TILE_SIZE = Math.max(TILE_SIZE, 30);

            // Canvasã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’è¨­å®š
            canvas.width = GRID_COLS * TILE_SIZE;
            canvas.height = GRID_ROWS * TILE_SIZE;

            // game-containerã®ã‚µã‚¤ã‚ºã‚‚Canvasã«åˆã‚ã›ã¦èª¿æ•´
            // padding: 10px; border: 4px; ãªã®ã§ã€å·¦å³ä¸Šä¸‹ãã‚Œãã‚Œ10+4=14pxå¢—ãˆã‚‹
            const containerPaddingBorder = 10 + 4; // padding + border-width
            gameContainer.style.width = `${canvas.width + (containerPaddingBorder * 2)}px`;
            gameContainer.style.height = `${canvas.height + (containerPaddingBorder * 2)}px`;
        }

        /**
         * ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã‚’åˆæœŸåŒ–ã—ã€åˆæœŸçŠ¶æ…‹ã§ãƒãƒƒãƒãŒãªã„ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã™ã€‚
         */
        function initBoard() {
            gameBoard = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS).fill(null));
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¢ã‚¤ãƒ†ãƒ ã‚’é…ç½®
                    let newItem;
                    do {
                        newItem = Math.floor(Math.random() * ITEM_TYPES);
                    } while (
                        // æ°´å¹³æ–¹å‘ã§æ—¢ã«2ã¤åŒã˜ã‚¢ã‚¤ãƒ†ãƒ ãŒä¸¦ã‚“ã§ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        (c >= 2 && gameBoard[r][c - 1] === newItem && gameBoard[r][c - 2] === newItem) ||
                        // å‚ç›´æ–¹å‘ã§æ—¢ã«2ã¤åŒã˜ã‚¢ã‚¤ãƒ†ãƒ ãŒä¸¦ã‚“ã§ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        (r >= 2 && gameBoard[r - 1][c] === newItem && gameBoard[r - 2][c] === newItem)
                    );
                    gameBoard[r][c] = newItem;
                }
            }
            drawBoard(); // åˆæœŸãƒœãƒ¼ãƒ‰ã‚’æç”»
        }

        /**
         * ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã‚’æç”»ã—ã¾ã™ã€‚
         * @param {number} [alpha=1] - æç”»ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã®é€æ˜åº¦ (0ã‹ã‚‰1)
         * @param {Array<Object>} [excludeTiles=[]] - æç”»ã‹ã‚‰é™¤å¤–ã™ã‚‹ã‚¿ã‚¤ãƒ«ã® {row, col} ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
         */
        function drawBoard(alpha = 1, excludeTiles = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢

            const excludeSet = new Set(excludeTiles.map(t => `${t.row},${t.col}`));
            const shakeStrength = 2; // æºã‚Œã®å¼·ã• (ãƒ”ã‚¯ã‚»ãƒ«)
            const shakeSpeed = 0.1; // æºã‚Œã®é€Ÿåº¦ (å°ã•ã„ã»ã©ã‚†ã£ãã‚Š)

            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (excludeSet.has(`${r},${c}`)) {
                        // ã“ã®ã‚¿ã‚¤ãƒ«ã¯é™¤å¤–ãƒªã‚¹ãƒˆã«ã‚ã‚‹ã®ã§æç”»ã—ãªã„ (ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§æç”»ã•ã‚Œã‚‹)
                        continue;
                    }

                    const itemType = gameBoard[r][c];
                    if (itemType !== null) {
                        let offsetX = 0;
                        let offsetY = 0;

                        if (isShaking) {
                            // å„ã‚¿ã‚¤ãƒ«ã«ç•°ãªã‚‹ã€æ™‚é–“ã§å¤‰åŒ–ã™ã‚‹æºã‚Œã‚’é©ç”¨
                            // performance.now() ã‚’ä½¿ã†ã“ã¨ã§ã€æ™‚é–“çµŒéã§æºã‚ŒãŒå¤‰åŒ–
                            // r, c ã‚’åŠ ãˆã‚‹ã“ã¨ã§ã€ã‚¿ã‚¤ãƒ«ã”ã¨ã«ç•°ãªã‚‹æºã‚Œæ–¹ã«ãªã‚‹
                            offsetX = Math.sin((performance.now() * shakeSpeed) + r * 1.2 + c * 0.8) * shakeStrength;
                            offsetY = Math.cos((performance.now() * shakeSpeed) + r * 0.8 + c * 1.2) * shakeStrength;
                        }

                        // ã‚¿ã‚¤ãƒ«ã®èƒŒæ™¯è‰² (çµµæ–‡å­—ã®èƒŒæ™¯ã¨ã—ã¦)
                        ctx.fillStyle = '#f8f8f8'; // è–„ã„ã‚°ãƒ¬ãƒ¼
                        ctx.fillRect(c * TILE_SIZE + offsetX, r * TILE_SIZE + offsetY, TILE_SIZE, TILE_SIZE);

                        ctx.globalAlpha = alpha; // é€æ˜åº¦ã‚’è¨­å®š
                        // çµµæ–‡å­—è¡¨ç¤ºã®ãƒ•ã‚©ãƒ³ãƒˆã‚¹ã‚¿ãƒƒã‚¯ã‚’æ”¹å–„
                        ctx.font = `${TILE_SIZE * 0.7}px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", "Segoe UI Symbol", "Twemoji Mozilla", "EmojiOne Color", "Android Emoji", sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(fruitEmojis[itemType], c * TILE_SIZE + TILE_SIZE / 2 + offsetX, r * TILE_SIZE + TILE_SIZE / 2 + offsetY);
                        ctx.globalAlpha = 1; // é€æ˜åº¦ã‚’ãƒªã‚»ãƒƒãƒˆ

                        // ã‚¿ã‚¤ãƒ«ã®å¢ƒç•Œç·š
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(c * TILE_SIZE + offsetX, r * TILE_SIZE + offsetY, TILE_SIZE, TILE_SIZE);
                    }

                    // é¸æŠä¸­ã®ã‚¿ã‚¤ãƒ«ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    if (selectedTile && selectedTile.row === r && selectedTile.col === c) {
                        // ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚‚æºã‚Œã«è¿½å¾“ã•ã›ã‚‹
                        let highlightOffsetX = 0;
                        let highlightOffsetY = 0;
                        if (isShaking) {
                            highlightOffsetX = Math.sin((performance.now() * shakeSpeed) + r * 1.2 + c * 0.8) * shakeStrength;
                            highlightOffsetY = Math.cos((performance.now() * shakeSpeed) + r * 0.8 + c * 1.2) * shakeStrength;
                        }
                        ctx.strokeStyle = '#FFD700'; // é¸æŠè‰² (ã‚´ãƒ¼ãƒ«ãƒ‰)
                        ctx.lineWidth = 4;
                        ctx.strokeRect(c * TILE_SIZE + 2 + highlightOffsetX, r * TILE_SIZE + 2 + highlightOffsetY, TILE_SIZE - 4, TILE_SIZE - 4);
                    }
                }
            }
        }

        let touchStartX, touchStartY; // ã‚¿ãƒƒãƒé–‹å§‹åº§æ¨™
        let touchStartTime; // ã‚¿ãƒƒãƒé–‹å§‹æ™‚åˆ»

        /**
         * ã‚¿ãƒƒãƒé–‹å§‹æ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
         * @param {TouchEvent} e - ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
         */
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãªã©ã‚’é˜²æ­¢
            if (isProcessing || isGameOver) return; // å‡¦ç†ä¸­ã¾ãŸã¯ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ä¸­ã¯å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ãªã„

            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();

            // ã‚¿ãƒƒãƒã•ã‚ŒãŸä½ç½®ã‹ã‚‰ã‚¿ã‚¤ãƒ«ã‚’ç‰¹å®š
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            const col = Math.floor(x / TILE_SIZE);
            const row = Math.floor(y / TILE_SIZE);

            if (row >= 0 && row < GRID_ROWS && col >= 0 && col < GRID_COLS) {
                selectedTile = { row, col };
                drawBoard(); // é¸æŠçŠ¶æ…‹ã‚’åæ˜ ã™ã‚‹ãŸã‚ã«å†æç”»
            }
        }, { passive: false }); // passive: false ã‚’è¨­å®šã—ã¦ preventDefault() ã‚’æœ‰åŠ¹ã«ã™ã‚‹

        /**
         * ã‚¿ãƒƒãƒçµ‚äº†æ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
         * @param {TouchEvent} e - ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
         */
        canvas.addEventListener('touchend', async (e) => {
            if (!selectedTile || isProcessing || isGameOver) return; // å‡¦ç†ä¸­ã¾ãŸã¯ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ä¸­ã¯å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ãªã„

            const touch = e.changedTouches[0];
            const touchEndX = touch.clientX;
            const touchEndY = touch.clientY;
            const touchEndTime = Date.now();

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const touchDuration = touchEndTime - touchStartTime;

            const swipeThreshold = TILE_SIZE * 0.5; // ãƒ•ãƒªãƒƒã‚¯ã¨åˆ¤å®šã™ã‚‹æœ€å°ç§»å‹•è·é›¢ (ã‚¿ã‚¤ãƒ«ã®åŠåˆ†)
            const maxTapDuration = 200; // ã‚¿ãƒƒãƒ—ã¨åˆ¤å®šã™ã‚‹æœ€å¤§æ™‚é–“ (ms)

            let targetTile = null;

            // ãƒ•ãƒªãƒƒã‚¯æ–¹å‘ã®åˆ¤å®š
            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > swipeThreshold) { // æ°´å¹³æ–¹å‘ã®ãƒ•ãƒªãƒƒã‚¯
                if (dx > 0) { // å³ãƒ•ãƒªãƒƒã‚¯
                    targetTile = { row: selectedTile.row, col: selectedTile.col + 1 };
                } else { // å·¦ãƒ•ãƒªãƒƒã‚¯
                    targetTile = { row: selectedTile.row, col: selectedTile.col - 1 };
                }
            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > swipeThreshold) { // å‚ç›´æ–¹å‘ã®ãƒ•ãƒªãƒƒã‚¯
                if (dy > 0) { // ä¸‹ãƒ•ãƒªãƒƒã‚¯
                    targetTile = { row: selectedTile.row + 1, col: selectedTile.col };
                } else { // ä¸Šãƒ•ãƒªãƒƒã‚¯
                    targetTile = { row: selectedTile.row - 1, col: selectedTile.col };
                }
            } else if (Math.abs(dx) <= swipeThreshold && Math.abs(dy) <= swipeThreshold && touchDuration < maxTapDuration) {
                // ç§»å‹•è·é›¢ãŒå°ã•ãã€æ™‚é–“ãŒçŸ­ã„å ´åˆã¯ã‚¿ãƒƒãƒ—ã¨ã¿ãªã™ (ã“ã“ã§ã¯ç‰¹ã«å‡¦ç†ãªã—ã€é¸æŠè§£é™¤ã®ã¿)
                selectedTile = null;
                drawBoard();
                return;
            }

            if (targetTile && isValidSwap(selectedTile, targetTile)) {
                isProcessing = true; // å‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä¼´ã£ã¦ã‚¢ã‚¤ãƒ†ãƒ ã‚’å…¥ã‚Œæ›¿ãˆã‚‹
                await animateSwap(selectedTile, targetTile);

                // å…¥ã‚Œæ›¿ãˆå¾Œã®ãƒãƒƒãƒåˆ¤å®š
                const matches = findMatches();
                if (matches.length > 0) {
                    await processGameCycle(); // ãƒãƒƒãƒå‡¦ç†ã€è½ä¸‹ã€è£œå……ã€é€£é–
                } else {
                    // ãƒãƒƒãƒã—ãªã‹ã£ãŸã‚‰å…ƒã«æˆ»ã™ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    await animateSwap(targetTile, selectedTile); // å…ƒã«æˆ»ã™
                }
            } else {
                selectedTile = null; // ç„¡åŠ¹ãªã‚¹ãƒ¯ã‚¤ãƒ—ãªã‚‰é¸æŠè§£é™¤
            }
            selectedTile = null; // é¸æŠã‚’è§£é™¤
            drawBoard(); // æœ€çµ‚çš„ãªãƒœãƒ¼ãƒ‰çŠ¶æ…‹ã‚’æç”»
            isProcessing = false; // å‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
        });

        /**
         * ã‚²ãƒ¼ãƒ ã®ã‚µã‚¤ã‚¯ãƒ« (ãƒãƒƒãƒå‡¦ç†ã€è½ä¸‹ã€è£œå……ã€é€£é–) ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
         */
        async function processGameCycle() {
            let matchesFound = true;
            while (matchesFound) {
                const matches = findMatches();
                if (matches.length > 0) {
                    addTime(TIME_BONUS_PER_MATCH); // å„ãƒãƒƒãƒï¼ˆé€£é–å«ã‚€ï¼‰ã§æ™‚é–“ã‚’è¿½åŠ 
                    await animateMatchRemoval(matches); // ãƒãƒƒãƒã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¶ˆå»ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    dropTiles(); // ã‚¢ã‚¤ãƒ†ãƒ ã‚’è½ä¸‹
                    await animateDrop(); // è½ä¸‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    fillEmptyTiles(); // ç©ºã®ãƒã‚¹ã«æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã‚’è£œå……
                    await animateFill(); // è£œå……ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                } else {
                    matchesFound = false; // ãƒãƒƒãƒãŒãªã‘ã‚Œã°ãƒ«ãƒ¼ãƒ—çµ‚äº†
                }
            }
        }

        /**
         * 2ã¤ã®ã‚¿ã‚¤ãƒ«ãŒå…¥ã‚Œæ›¿ãˆå¯èƒ½ã‹åˆ¤å®šã—ã¾ã™ã€‚
         * @param {Object} tile1 - 1ã¤ç›®ã®ã‚¿ã‚¤ãƒ« {row, col}
         * @param {Object} tile2 - 2ã¤ç›®ã®ã‚¿ã‚¤ãƒ« {row, col}
         * @returns {boolean} - å…¥ã‚Œæ›¿ãˆå¯èƒ½ãªã‚‰true
         */
        function isValidSwap(tile1, tile2) {
            // ç›¤é¢å¤–ã‹ã©ã†ã‹ã®ãƒã‚§ãƒƒã‚¯
            if (tile2.row < 0 || tile2.row >= GRID_ROWS || tile2.col < 0 || tile2.col >= GRID_COLS) {
                return false;
            }
            // éš£æ¥ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã®ãƒã‚§ãƒƒã‚¯ (ç¸¦ã‹æ¨ªã«1ãƒã‚¹ã ã‘é›¢ã‚Œã¦ã„ã‚‹)
            const dr = Math.abs(tile1.row - tile2.row);
            const dc = Math.abs(tile1.col - tile2.col);
            return (dr === 1 && dc === 0) || (dr === 0 && dc === 1);
        }

        /**
         * ã‚¢ã‚¤ãƒ†ãƒ ã®å…¥ã‚Œæ›¿ãˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã€ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
         * @param {Object} tile1 - å…¥ã‚Œæ›¿ãˆã‚‹1ã¤ç›®ã®ã‚¿ã‚¤ãƒ« {row, col}
         * @param {Object} tile2 - å…¥ã‚Œæ›¿ãˆã‚‹2ã¤ç›®ã®ã‚¿ã‚¤ãƒ« {row, col}
         * @returns {Promise<void>} - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã«è§£æ±ºã™ã‚‹Promise
         */
        async function animateSwap(tile1, tile2) {
            const item1 = gameBoard[tile1.row][tile1.col];
            const item2 = gameBoard[tile2.row][tile2.col];

            // ä»®æƒ³çš„ãªä½ç½®æƒ…å ±ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            const animatedTiles = [
                { type: item1, x: tile1.col * TILE_SIZE, y: tile1.row * TILE_SIZE, targetX: tile2.col * TILE_SIZE, targetY: tile2.row * TILE_SIZE },
                { type: item2, x: tile2.col * TILE_SIZE, y: tile2.row * TILE_SIZE, targetX: tile1.col * TILE_SIZE, targetY: tile1.row * TILE_SIZE }
            ];

            const startTime = performance.now();

            return new Promise(resolve => {
                function animate() {
                    const elapsed = performance.now() - startTime;
                    const progress = Math.min(elapsed / SWAP_ANIMATION_DURATION, 1); // 0ã‹ã‚‰1ã«æ­£è¦åŒ–

                    // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã®ã‚¿ã‚¤ãƒ«ã¯drawBoardã§æç”»ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
                    drawBoard(1, [tile1, tile2]);

                    animatedTiles.forEach(tile => {
                        const currentX = tile.x + (tile.targetX - tile.x) * progress;
                        const currentY = tile.y + (tile.targetY - tile.y) * progress;
                        
                        // å‹•ã„ã¦ã„ã‚‹ã‚¿ã‚¤ãƒ«ã®èƒŒæ™¯ã‚’æç”»
                        ctx.fillStyle = '#f8f8f8'; // è–„ã„ã‚°ãƒ¬ãƒ¼ã®èƒŒæ™¯
                        ctx.fillRect(currentX, currentY, TILE_SIZE, TILE_SIZE);

                        // çµµæ–‡å­—è¡¨ç¤ºã®ãƒ•ã‚©ãƒ³ãƒˆã‚¹ã‚¿ãƒƒã‚¯ã‚’æ”¹å–„
                        ctx.font = `${TILE_SIZE * 0.7}px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", "Segoe UI Symbol", "Twemoji Mozilla", "EmojiOne Color", "Android Emoji", sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(fruitEmojis[tile.type], currentX + TILE_SIZE / 2, currentY + TILE_SIZE / 2);

                        // å‹•ã„ã¦ã„ã‚‹ã‚¿ã‚¤ãƒ«ã®å¢ƒç•Œç·š
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(currentX, currentY, TILE_SIZE, TILE_SIZE);
                    });

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã€å®Ÿéš›ã®ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°
                        gameBoard[tile1.row][tile1.col] = item2;
                        gameBoard[tile2.row][tile2.col] = item1;
                        drawBoard(); // æœ€çµ‚çš„ãªçŠ¶æ…‹ã‚’æç”»
                        resolve();
                    }
                }
                requestAnimationFrame(animate);
            });
        }

        /**
         * ãƒãƒƒãƒã—ã¦ã„ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¤œå‡ºã—ã€ãã®åº§æ¨™ã®é…åˆ—ã‚’è¿”ã—ã¾ã™ã€‚
         * @returns {Array<Object>} - ãƒãƒƒãƒã—ãŸã‚¿ã‚¤ãƒ«ã® {row, col} ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
         */
        function findMatches() {
            const matches = new Set(); // é‡è¤‡ã‚’é¿ã‘ã‚‹ãŸã‚ã«Setã‚’ä½¿ç”¨

            // æ°´å¹³æ–¹å‘ã®ãƒãƒƒãƒã‚’æ¤œå‡º
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS - 2; c++) {
                    const item = gameBoard[r][c];
                    if (item !== null && item === gameBoard[r][c + 1] && item === gameBoard[r][c + 2]) {
                        // 3ã¤ä»¥ä¸Šä¸¦ã‚“ã§ã„ã‚‹å ´åˆ
                        let i = c;
                        while (i < GRID_COLS && gameBoard[r][i] === item) {
                            matches.add(JSON.stringify({ row: r, col: i }));
                            i++;
                        }
                    }
                }
            }

            // å‚ç›´æ–¹å‘ã®ãƒãƒƒãƒã‚’æ¤œå‡º
            for (let c = 0; c < GRID_COLS; c++) {
                for (let r = 0; r < GRID_ROWS - 2; r++) {
                    const item = gameBoard[r][c];
                    if (item !== null && item === gameBoard[r + 1][c] && item === gameBoard[r + 2][c]) {
                        let i = r;
                        while (i < GRID_ROWS && gameBoard[i][c] === item) {
                            matches.add(JSON.stringify({ row: i, col: c }));
                            i++;
                        }
                    }
                }
            }
            return Array.from(matches).map(s => JSON.parse(s));
        }

        /**
         * ãƒãƒƒãƒã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¶ˆå»ã™ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
         * @param {Array<Object>} matches - æ¶ˆå»ã™ã‚‹ã‚¿ã‚¤ãƒ«ã® {row, col} ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
         * @returns {Promise<void>} - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã«è§£æ±ºã™ã‚‹Promise
         */
        async function animateMatchRemoval(matches) {
            const startTime = performance.now();
            const tilesToRemove = matches.map(match => ({
                row: match.row,
                col: match.col,
                originalType: gameBoard[match.row][match.col] // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã«å…ƒã®ã‚¿ã‚¤ãƒ—ã‚’ä¿æŒ
            }));

            return new Promise(resolve => {
                function animate() {
                    const elapsed = performance.now() - startTime;
                    const progress = Math.min(elapsed / MATCH_FADE_DURATION, 1); // 0ã‹ã‚‰1ã«æ­£è¦åŒ–
                    const alpha = 1 - progress; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ

                    // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆä¸­ã®ã‚¿ã‚¤ãƒ«ã¯drawBoardã§æç”»ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
                    drawBoard(1, tilesToRemove);

                    // æ¶ˆå»å¯¾è±¡ã®ã‚¿ã‚¤ãƒ«ã ã‘é€æ˜åº¦ã‚’ä¸‹ã’ã¦æç”»
                    tilesToRemove.forEach(tile => {
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = '#f8f8f8'; // è–„ã„ã‚°ãƒ¬ãƒ¼ã®èƒŒæ™¯
                        ctx.fillRect(tile.col * TILE_SIZE, tile.row * TILE_SIZE, TILE_SIZE, TILE_SIZE); // èƒŒæ™¯ã‚’æç”»
                        // çµµæ–‡å­—è¡¨ç¤ºã®ãƒ•ã‚©ãƒ³ãƒˆã‚¹ã‚¿ãƒƒã‚¯ã‚’æ”¹å–„
                        ctx.font = `${TILE_SIZE * 0.7}px "Segoe UI Emoji", "Apple Color Emoji", "Noto Color Emoji", "Segoe UI Symbol", "Twemoji Mozilla", "EmojiOne Color", "Android Emoji", sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(fruitEmojis[tile.originalType], tile.col * TILE_SIZE + TILE_SIZE / 2, tile.row * TILE_SIZE + TILE_SIZE / 2);
                        ctx.globalAlpha = 1;
                    });

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã€ãƒœãƒ¼ãƒ‰ã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤
                        matches.forEach(match => {
                            gameBoard[match.row][match.col] = null;
                        });
                        drawBoard(); // æœ€çµ‚çš„ãªçŠ¶æ…‹ã‚’æç”»
                        resolve();
                    }
                }
                requestAnimationFrame(animate);
            });
        }

        /**
         * ã‚¢ã‚¤ãƒ†ãƒ ã‚’è½ä¸‹ã•ã›ã€ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
         */
        function dropTiles() {
            for (let c = 0; c < GRID_COLS; c++) {
                let emptySpaces = 0; // ãã®åˆ—ã®ç©ºããƒã‚¹ã®æ•°
                for (let r = GRID_ROWS - 1; r >= 0; r--) {
                    if (gameBoard[r][c] === null) {
                        emptySpaces++;
                    } else if (emptySpaces > 0) {
                        // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç©ºããƒã‚¹ã®æ•°ã ã‘ä¸‹ã«ç§»å‹•
                        gameBoard[r + emptySpaces][c] = gameBoard[r][c];
                        gameBoard[r][c] = null;
                    }
                }
            }
        }

        /**
         * ã‚¢ã‚¤ãƒ†ãƒ è½ä¸‹ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
         * (å®Ÿéš›ã«ã¯dropTiles()ã§çŠ¶æ…‹ãŒæ›´æ–°ã•ã‚ŒãŸå¾Œã«ã€ãã®å¤‰åŒ–ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§è¡¨ç¾)
         * @returns {Promise<void>} - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã«è§£æ±ºã™ã‚‹Promise
         */
        async function animateDrop() {
            // ã“ã®é–¢æ•°ã¯ã€dropTiles()ã«ã‚ˆã£ã¦æ›´æ–°ã•ã‚ŒãŸãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’å…ƒã«ã€
            // å®Ÿéš›ã«ã‚¿ã‚¤ãƒ«ãŒè½ã¡ã‚‹ã‚ˆã†ã«è¦‹ã›ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
            // ç°¡ç•¥åŒ–ã®ãŸã‚ã€ã“ã“ã§ã¯å˜ç´”ã«setTimeoutã§å¾…ã¤ã ã‘ã«ã—ã¾ã™ã€‚
            // ã‚ˆã‚Šé«˜åº¦ãªå®Ÿè£…ã§ã¯ã€å„ã‚¿ã‚¤ãƒ«ã®é–‹å§‹Yåº§æ¨™ã¨çµ‚äº†Yåº§æ¨™ã‚’è¨ˆç®—ã—ã€
            // requestAnimationFrameã§è£œé–“ã—ã¦æç”»ã—ã¾ã™ã€‚
            drawBoard(); // è½ä¸‹å¾Œã®çŠ¶æ…‹ã‚’å³æ™‚æç”» (ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—)
            return new Promise(resolve => setTimeout(resolve, DROP_ANIMATION_DURATION));
        }

        /**
         * ç©ºã®ãƒã‚¹ã«æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã‚’è£œå……ã—ã€ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
         */
        function fillEmptyTiles() {
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (gameBoard[r][c] === null) {
                        gameBoard[r][c] = Math.floor(Math.random() * ITEM_TYPES);
                    }
                }
            }
        }

        /**
         * æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ è£œå……ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
         * (å®Ÿéš›ã«ã¯fillEmptyTiles()ã§çŠ¶æ…‹ãŒæ›´æ–°ã•ã‚ŒãŸå¾Œã«ã€ãã®å¤‰åŒ–ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§è¡¨ç¾)
         * @returns {Promise<void>} - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã«è§£æ±ºã™ã‚‹Promise
         */
        async function animateFill() {
            // ã“ã®é–¢æ•°ã¯ã€fillEmptyTiles()ã«ã‚ˆã£ã¦æ›´æ–°ã•ã‚ŒãŸãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’å…ƒã«ã€
            // æ–°ã—ã„ã‚¿ã‚¤ãƒ«ãŒä¸Šã‹ã‚‰é™ã£ã¦ãã‚‹ã‚ˆã†ã«è¦‹ã›ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
            // ç°¡ç•¥åŒ–ã®ãŸã‚ã€ã“ã“ã§ã¯å˜ç´”ã«setTimeoutã§å¾…ã¤ã ã‘ã«ã—ã¾ã™ã€‚
            drawBoard(); // è£œå……å¾Œã®çŠ¶æ…‹ã‚’å³æ™‚æç”» (ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—)
            return new Promise(resolve => setTimeout(resolve, 200)); // å°‘ã—å¾…ã¤
        }

        /**
         * ã‚¿ã‚¤ãƒ ãƒãƒ¼ã®è¡¨ç¤ºã‚’æ›´æ–°ã—ã¾ã™ã€‚
         */
        function updateTimeBarDisplay() {
            const percentage = (gameTime / MAX_GAME_TIME) * 100;
            timeBarFill.style.width = `${percentage}%`;

            // ã‚¿ã‚¤ãƒ ãƒãƒ¼ã®è‰²ã‚’æ™‚é–“ã«å¿œã˜ã¦å¤‰æ›´
            if (percentage > 50) {
                timeBarFill.style.backgroundColor = '#4CAF50'; // ç·‘
            } else if (percentage > 20) {
                timeBarFill.style.backgroundColor = '#FFD700'; // é»„è‰²
            } else {
                timeBarFill.style.backgroundColor = '#FF6347'; // èµ¤
            }

            // æ®‹ã‚Šæ™‚é–“ãŒå°‘ãªã„å ´åˆã«ãƒ‘ãƒãƒ«ã‚’éœ‡ã‚ã›ã‚‹
            if (gameTime <= MAX_GAME_TIME * LOW_TIME_THRESHOLD_RATIO && !isShaking) {
                startShaking();
            } else if (gameTime > MAX_GAME_TIME * LOW_TIME_THRESHOLD_RATIO && isShaking) {
                stopShaking();
            }
        }

        /**
         * æ™‚é–“ã‚’æ¸›ã‚‰ã—ã€ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¾ã™ã€‚
         */
        function updateTime() {
            gameTime--;
            updateTimeBarDisplay();
            if (gameTime <= 0) {
                gameOver();
            }
        }

        /**
         * ã‚²ãƒ¼ãƒ ã«æ™‚é–“ã‚’è¿½åŠ ã—ã¾ã™ã€‚
         * @param {number} amount - è¿½åŠ ã™ã‚‹æ™‚é–“ (ç§’)
         */
        function addTime(amount) {
            gameTime = Math.min(gameTime + amount, MAX_GAME_TIME);
            updateTimeBarDisplay();
        }

        /**
         * ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å‡¦ç†ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
         */
        function gameOver() {
            clearInterval(timeUpdateInterval); // ã‚¿ã‚¤ãƒãƒ¼ã‚’åœæ­¢
            stopShaking(); // æºã‚Œã‚’åœæ­¢
            isGameOver = true;
            gameOverPopup.style.display = 'flex'; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’è¡¨ç¤º
        }

        /**
         * ãƒ‘ãƒãƒ«ã®æºã‚Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’é–‹å§‹ã—ã¾ã™ã€‚
         */
        function startShaking() {
            isShaking = true;
            if (!shakeAnimationId) { // æ—¢ã«ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒé–‹å§‹ã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿
                function shakeLoop() {
                    drawBoard(); // æºã‚Œã‚’åæ˜ ã™ã‚‹ãŸã‚ã«å†æç”»
                    if (isShaking) { // isShakingãŒtrueã®é–“ã ã‘ãƒ«ãƒ¼ãƒ—ã‚’ç¶šã‘ã‚‹
                        shakeAnimationId = requestAnimationFrame(shakeLoop);
                    } else {
                        shakeAnimationId = null; // ãƒ«ãƒ¼ãƒ—çµ‚äº†æ™‚ã«IDã‚’ã‚¯ãƒªã‚¢
                    }
                }
                shakeAnimationId = requestAnimationFrame(shakeLoop);
            }
        }

        /**
         * ãƒ‘ãƒãƒ«ã®æºã‚Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢ã—ã¾ã™ã€‚
         */
        function stopShaking() {
            isShaking = false;
            if (shakeAnimationId) {
                cancelAnimationFrame(shakeAnimationId);
                shakeAnimationId = null;
            }
            drawBoard(); // æºã‚ŒãŒæ­¢ã¾ã£ãŸçŠ¶æ…‹ã§ä¸€åº¦æç”»ã—ç›´ã™
        }

        /**
         * ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã™ã€‚
         */
        function startGame() {
            isGameOver = false;
            gameTime = MAX_GAME_TIME; // æ™‚é–“ã‚’ãƒªã‚»ãƒƒãƒˆ
            gameOverPopup.style.display = 'none'; // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ã‚’éè¡¨ç¤º
            updateTimeBarDisplay(); // ã‚¿ã‚¤ãƒ ãƒãƒ¼ã‚’åˆæœŸåŒ–
            if (timeUpdateInterval) clearInterval(timeUpdateInterval); // æ—¢å­˜ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢
            timeUpdateInterval = setInterval(updateTime, 1000); // 1ç§’ã”ã¨ã«æ™‚é–“ã‚’æ›´æ–°
            initBoard(); // ãƒœãƒ¼ãƒ‰ã‚’åˆæœŸåŒ–
            // ã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã«æºã‚Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã¯åœæ­¢ã—ã¦ãŠã
            stopShaking();
        }

        /**
         * ã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¦æœ€åˆã‹ã‚‰ãƒ—ãƒ¬ã‚¤ã—ã¾ã™ã€‚
         */
        function resetGame() {
            // æ—¢å­˜ã®ã‚¿ã‚¤ãƒãƒ¼ãŒã‚ã‚Œã°ã‚¯ãƒªã‚¢
            if (timeUpdateInterval) {
                clearInterval(timeUpdateInterval);
            }
            // æºã‚Œã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãŒã‚ã‚Œã°åœæ­¢
            stopShaking();
            startGame(); // æ–°ã—ã„ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹
        }

        // --- ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ ---
        playAgainButton.addEventListener('click', resetGame);

        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆã«å¯¾å¿œ (Canvasã‚µã‚¤ã‚ºã‚’å†è¨­å®šã—ã€å†æç”»)
        window.addEventListener('resize', () => {
            calculateCanvasSize(); // ã‚µã‚¤ã‚ºã‚’å†è¨ˆç®—
            drawBoard(); // å†æç”»
        });

        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‚‚è¿½åŠ  (ãƒ‡ãƒãƒƒã‚°ç”¨ã‚„PCã§ã®æ“ä½œç”¨)
        let mouseStartX, mouseStartY;
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (isProcessing || isGameOver) return; // å‡¦ç†ä¸­ã¾ãŸã¯ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ä¸­ã¯å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ãªã„

            mouseStartX = e.clientX;
            mouseStartY = e.clientY;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.floor(x / TILE_SIZE);
            const row = Math.floor(y / TILE_SIZE);

            if (row >= 0 && row < GRID_ROWS && col >= 0 && col < GRID_COLS) {
                selectedTile = { row, col };
                drawBoard();
            }
        });

        canvas.addEventListener('mouseup', async (e) => {
            if (!selectedTile || isProcessing || isGameOver) return; // å‡¦ç†ä¸­ã¾ãŸã¯ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ä¸­ã¯å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ãªã„

            const dx = e.clientX - mouseStartX;
            const dy = e.clientY - mouseStartY;

            const swipeThreshold = TILE_SIZE * 0.5; // ãƒ•ãƒªãƒƒã‚¯ã¨åˆ¤å®šã™ã‚‹æœ€å°ç§»å‹•è·é›¢ (ã‚¿ã‚¤ãƒ«ã®åŠåˆ†)

            let targetTile = null;

            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > swipeThreshold) {
                if (dx > 0) {
                    targetTile = { row: selectedTile.row, col: selectedTile.col + 1 };
                } else {
                    targetTile = { row: selectedTile.row, col: selectedTile.col - 1 };
                }
            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > swipeThreshold) {
                if (dy > 0) {
                    targetTile = { row: selectedTile.row + 1, col: selectedTile.col };
                } else {
                    targetTile = { row: selectedTile.row - 1, col: selectedTile.col };
                }
            }

            if (targetTile && isValidSwap(selectedTile, targetTile)) {
                isProcessing = true;
                await animateSwap(selectedTile, targetTile);

                const matches = findMatches();
                if (matches.length > 0) {
                    await processGameCycle();
                } else {
                    await animateSwap(targetTile, selectedTile);
                }
            } else {
                selectedTile = null;
            }
            selectedTile = null;
            drawBoard();
            isProcessing = false;
        });

        // --- ã‚²ãƒ¼ãƒ é–‹å§‹ ---
        calculateCanvasSize(); // Canvasã®ã‚µã‚¤ã‚ºã‚’åˆæœŸè¨­å®š
        startGame(); // ã‚²ãƒ¼ãƒ ã‚’åˆæœŸåŒ–ã—ã¦é–‹å§‹
    </script>
</body>
</html>
