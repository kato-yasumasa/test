<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ï¼“ãƒãƒƒãƒãƒ‘ã‚ºãƒ«</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* style.css ã®å†…å®¹ã‚’ã“ã“ã«ç›´æ¥è¨˜è¿° */
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: 'Inter', sans-serif; /* ãƒ•ã‚©ãƒ³ãƒˆã‚’Interã«è¨­å®š */
            color: #333;
        }

        h1 {
            margin-bottom: 20px;
            color: #4a4a4a;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        #game-container {
            border: 4px solid #8B4513; /* æœ¨ç›®èª¿ã®æ  */
            background-color: #fff;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            border-radius: 15px; /* è§’ã‚’ä¸¸ã */
            /* overflow: hidden; /* è§’ä¸¸ã«åˆã‚ã›ã¦å†…å®¹ã‚’ã‚¯ãƒªãƒƒãƒ— */
            padding: 10px; /* å†…å´ã®ä½™ç™½ */
            position: relative; /* é¸æŠãƒã‚¤ãƒ©ã‚¤ãƒˆç”¨ */
            /* å¹…ã¨é«˜ã•ã¯JavaScriptã§å‹•çš„ã«è¨­å®š */

            /* Canvasã‚’ä¸­å¤®ã«é…ç½®ã™ã‚‹ãŸã‚ã®Flexboxè¨­å®šã‚’è¿½åŠ  */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background-color: #eee; /* ã‚¿ã‚¤ãƒ«ãŒãªã„éƒ¨åˆ†ã®èƒŒæ™¯è‰² */
            border-radius: 10px; /* Canvasè‡ªä½“ã‚‚è§’ã‚’ä¸¸ã */
        }

        /* ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ã®ã‚¹ã‚¿ã‚¤ãƒ« */
        #message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 10px;
            z-index: 1000;
            display: none; /* åˆæœŸçŠ¶æ…‹ã§ã¯éè¡¨ç¤º */
            text-align: center;
            font-size: 1.2em;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        }

        #message-box button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
        }

        #message-box button:hover {
            background-color: #45a049;
        }

        /* ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®ã‚¹ã‚¿ã‚¤ãƒ«ã¯ã€çµµæ–‡å­—æç”»ã®ãŸã‚ä¸è¦ã«ãªã‚Šã¾ã—ãŸãŒã€
           å¿µã®ãŸã‚ã‚¹ã‚¿ã‚¤ãƒ«ã¯æ®‹ã—ã¦ãŠãã¾ã™ã€‚HTMLã‹ã‚‰ã¯å‰Šé™¤ã•ã‚Œã¦ã„ã¾ã™ã€‚ */
        #loading-message {
            display: none; /* å¸¸ã«éè¡¨ç¤º */
        }
    </style>
</head>
<body>
    <h1>ï¼“ãƒãƒƒãƒãƒ‘ã‚ºãƒ«</h1>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="message-box">
        <p id="message-text"></p>
        <button id="message-button">OK</button>
    </div>

    <!-- ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã¯çµµæ–‡å­—æç”»ã®ãŸã‚ä¸è¦ã«ãªã‚Šã¾ã—ãŸ -->
    <!-- <div id="loading-message">
        <div class="spinner"></div>
        <p>ç”»åƒã‚’èª­ã¿è¾¼ã¿ä¸­...</p>
    </div> -->

    <script>
        // script.js ã®å†…å®¹ã‚’ã“ã“ã«ç›´æ¥è¨˜è¿°
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageButton = document.getElementById('message-button');
        const gameContainer = document.getElementById('game-container');
        // const loadingMessage = document.getElementById('loading-message'); // ä¸è¦ã«ãªã£ãŸãŸã‚ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆ

        let TILE_SIZE; // 1ã‚¿ã‚¤ãƒ«ã®ã‚µã‚¤ã‚º (px) - å‹•çš„ã«è¨ˆç®—ã•ã‚Œã‚‹
        const GRID_COLS = 8; // ã‚°ãƒªãƒƒãƒ‰ã®åˆ—æ•°
        const GRID_ROWS = 8; // ã‚°ãƒªãƒƒãƒ‰ã®è¡Œæ•°
        const ITEM_TYPES = 5; // ã‚¢ã‚¤ãƒ†ãƒ ã®ç¨®é¡æ•° (0-4ã®æ•°å€¤ã§è¡¨ç¾)
        const SWAP_ANIMATION_DURATION = 200; // å…¥ã‚Œæ›¿ãˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ™‚é–“ (ms)
        const MATCH_FADE_DURATION = 300; // ãƒãƒƒãƒæ¶ˆå»ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ™‚é–“ (ms)
        const DROP_ANIMATION_DURATION = 400; // è½ä¸‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã®æ™‚é–“ (ms)

        let gameBoard = []; // ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’ä¿æŒã™ã‚‹äºŒæ¬¡å…ƒé…åˆ—
        let selectedTile = null; // é¸æŠã•ã‚ŒãŸã‚¿ã‚¤ãƒ« {row, col}
        let isProcessing = false; // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ä¸­ã‚„å‡¦ç†ä¸­ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°

        // å„ã‚¢ã‚¤ãƒ†ãƒ ã®çµµæ–‡å­—ã‚’å®šç¾©
        const fruitEmojis = [
            'ğŸ', // Apple
            'ğŸŒ', // Banana
            'ğŸ‡', // Grape
            'ğŸŠ', // Orange
            'ğŸ“'  // Strawberry
        ];

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ã‚’è¡¨ç¤ºã™ã‚‹é–¢æ•° (alertã®ä»£æ›¿)
        function showMessageBox(message) {
            messageText.textContent = message;
            messageBox.style.display = 'block';
        }

        // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒœãƒƒã‚¯ã‚¹ã‚’éè¡¨ç¤ºã«ã™ã‚‹é–¢æ•°
        messageButton.addEventListener('click', () => {
            messageBox.style.display = 'none';
        });

        /**
         * Canvasã¨ã‚¿ã‚¤ãƒ«ã®ã‚µã‚¤ã‚ºã‚’ç”»é¢ã«åˆã‚ã›ã¦è¨ˆç®—ã—ã€è¨­å®šã—ã¾ã™ã€‚
         */
        function calculateCanvasSize() {
            // ç”»é¢ã®åˆ©ç”¨å¯èƒ½ãªå¹…ã¨é«˜ã•ã‹ã‚‰ã€ãƒœãƒ¼ãƒ‰ã®æœ€å¤§ã‚µã‚¤ã‚ºã‚’æ±ºå®š
            // å·¦å³ã«å°‘ã—ä½™ç™½ã‚’æŒãŸã›ã‚‹ãŸã‚ã€ç”»é¢å¹…ã®95%ã‚’ä½¿ç”¨
            const maxBoardWidth = window.innerWidth * 0.95;
            // ä¸Šä¸‹ã«ã‚‚ä½™ç™½ã‚’æŒãŸã›ã‚‹ãŸã‚ã€ç”»é¢é«˜ã•ã®80%ã‚’ä½¿ç”¨ (ãƒ˜ãƒƒãƒ€ãƒ¼ãªã©ã‚’è€ƒæ…®)
            const maxBoardHeight = window.innerHeight * 0.80;

            // 1ã‚¿ã‚¤ãƒ«ã‚ãŸã‚Šã®æœ€å¤§ã‚µã‚¤ã‚ºã‚’ã€å¹…ã¨é«˜ã•ã®ä¸¡æ–¹ã‹ã‚‰è¨ˆç®—
            const potentialTileSizeByWidth = Math.floor(maxBoardWidth / GRID_COLS);
            const potentialTileSizeByHeight = Math.floor(maxBoardHeight / GRID_ROWS);

            // ã©ã¡ã‚‰ã‹å°ã•ã„æ–¹ã‚’æ¡ç”¨ã—ã¦ã€ãƒœãƒ¼ãƒ‰å…¨ä½“ãŒç”»é¢å†…ã«åã¾ã‚‹ã‚ˆã†ã«ã™ã‚‹
            TILE_SIZE = Math.min(potentialTileSizeByWidth, potentialTileSizeByHeight);

            // ã‚¿ã‚¤ãƒ«ãŒå°ã•ããªã‚Šã™ããªã„ã‚ˆã†ã«æœ€å°ã‚µã‚¤ã‚ºã‚’è¨­å®š (ä¾‹: 30px)
            TILE_SIZE = Math.max(TILE_SIZE, 30);

            // Canvasã®å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚’è¨­å®š
            canvas.width = GRID_COLS * TILE_SIZE;
            canvas.height = GRID_ROWS * TILE_SIZE;

            // game-containerã®ã‚µã‚¤ã‚ºã‚‚Canvasã«åˆã‚ã›ã¦èª¿æ•´
            // padding: 10px; border: 4px; ãªã®ã§ã€å·¦å³ä¸Šä¸‹ãã‚Œãã‚Œ10+4=14pxå¢—ãˆã‚‹
            const containerPaddingBorder = 10 + 4; // padding + border-width
            gameContainer.style.width = `${canvas.width + (containerPaddingBorder * 2)}px`;
            gameContainer.style.height = `${canvas.height + (containerPaddingBorder * 2)}px`;
        }

        /**
         * ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã‚’åˆæœŸåŒ–ã—ã€åˆæœŸçŠ¶æ…‹ã§ãƒãƒƒãƒãŒãªã„ã“ã¨ã‚’ä¿è¨¼ã—ã¾ã™ã€‚
         */
        function initBoard() {
            gameBoard = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS).fill(null));
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    // ãƒ©ãƒ³ãƒ€ãƒ ãªã‚¢ã‚¤ãƒ†ãƒ ã‚’é…ç½®
                    let newItem;
                    do {
                        newItem = Math.floor(Math.random() * ITEM_TYPES);
                    } while (
                        // æ°´å¹³æ–¹å‘ã§æ—¢ã«2ã¤åŒã˜ã‚¢ã‚¤ãƒ†ãƒ ãŒä¸¦ã‚“ã§ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        (c >= 2 && gameBoard[r][c - 1] === newItem && gameBoard[r][c - 2] === newItem) ||
                        // å‚ç›´æ–¹å‘ã§æ—¢ã«2ã¤åŒã˜ã‚¢ã‚¤ãƒ†ãƒ ãŒä¸¦ã‚“ã§ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        (r >= 2 && gameBoard[r - 1][c] === newItem && gameBoard[r - 2][c] === newItem)
                    );
                    gameBoard[r][c] = newItem;
                }
            }
            drawBoard(); // åˆæœŸãƒœãƒ¼ãƒ‰ã‚’æç”»
        }

        /**
         * ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ã‚’æç”»ã—ã¾ã™ã€‚
         * @param {number} [alpha=1] - æç”»ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã®é€æ˜åº¦ (0ã‹ã‚‰1)
         */
        function drawBoard(alpha = 1) {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢

            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const itemType = gameBoard[r][c];
                    if (itemType !== null) {
                        // ã‚¿ã‚¤ãƒ«ã®èƒŒæ™¯è‰² (çµµæ–‡å­—ã®èƒŒæ™¯ã¨ã—ã¦)
                        ctx.fillStyle = '#f8f8f8'; // è–„ã„ã‚°ãƒ¬ãƒ¼
                        ctx.fillRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);

                        ctx.globalAlpha = alpha; // é€æ˜åº¦ã‚’è¨­å®š
                        ctx.font = `${TILE_SIZE * 0.7}px Arial`; // çµµæ–‡å­—ã®ã‚µã‚¤ã‚ºã‚’èª¿æ•´
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(fruitEmojis[itemType], c * TILE_SIZE + TILE_SIZE / 2, r * TILE_SIZE + TILE_SIZE / 2);
                        ctx.globalAlpha = 1; // é€æ˜åº¦ã‚’ãƒªã‚»ãƒƒãƒˆ

                        // ã‚¿ã‚¤ãƒ«ã®å¢ƒç•Œç·š
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1;
                        ctx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                    }

                    // é¸æŠä¸­ã®ã‚¿ã‚¤ãƒ«ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                    if (selectedTile && selectedTile.row === r && selectedTile.col === c) {
                        ctx.strokeStyle = '#FFD700'; // é¸æŠè‰² (ã‚´ãƒ¼ãƒ«ãƒ‰)
                        ctx.lineWidth = 4;
                        ctx.strokeRect(c * TILE_SIZE + 2, r * TILE_SIZE + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                    }
                }
            }
        }

        let touchStartX, touchStartY; // ã‚¿ãƒƒãƒé–‹å§‹åº§æ¨™
        let touchStartTime; // ã‚¿ãƒƒãƒé–‹å§‹æ™‚åˆ»

        /**
         * ã‚¿ãƒƒãƒé–‹å§‹æ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
         * @param {TouchEvent} e - ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
         */
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãªã©ã‚’é˜²æ­¢
            if (isProcessing) return; // å‡¦ç†ä¸­ã¯å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ãªã„

            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();

            // ã‚¿ãƒƒãƒã•ã‚ŒãŸä½ç½®ã‹ã‚‰ã‚¿ã‚¤ãƒ«ã‚’ç‰¹å®š
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            const col = Math.floor(x / TILE_SIZE);
            const row = Math.floor(y / TILE_SIZE);

            if (row >= 0 && row < GRID_ROWS && col >= 0 && col < GRID_COLS) {
                selectedTile = { row, col };
                drawBoard(); // é¸æŠçŠ¶æ…‹ã‚’åæ˜ ã™ã‚‹ãŸã‚ã«å†æç”»
            }
        }, { passive: false }); // passive: false ã‚’è¨­å®šã—ã¦ preventDefault() ã‚’æœ‰åŠ¹ã«ã™ã‚‹

        /**
         * ã‚¿ãƒƒãƒçµ‚äº†æ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒ©
         * @param {TouchEvent} e - ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
         */
        canvas.addEventListener('touchend', async (e) => {
            if (!selectedTile || isProcessing) return;

            const touch = e.changedTouches[0];
            const touchEndX = touch.clientX;
            const touchEndY = touch.clientY;
            const touchEndTime = Date.now();

            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            const touchDuration = touchEndTime - touchStartTime;

            const swipeThreshold = TILE_SIZE * 0.5; // ãƒ•ãƒªãƒƒã‚¯ã¨åˆ¤å®šã™ã‚‹æœ€å°ç§»å‹•è·é›¢ (ã‚¿ã‚¤ãƒ«ã®åŠåˆ†)
            const maxTapDuration = 200; // ã‚¿ãƒƒãƒ—ã¨åˆ¤å®šã™ã‚‹æœ€å¤§æ™‚é–“ (ms)

            let targetTile = null;

            // ãƒ•ãƒªãƒƒã‚¯æ–¹å‘ã®åˆ¤å®š
            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > swipeThreshold) { // æ°´å¹³æ–¹å‘ã®ãƒ•ãƒªãƒƒã‚¯
                if (dx > 0) { // å³ãƒ•ãƒªãƒƒã‚¯
                    targetTile = { row: selectedTile.row, col: selectedTile.col + 1 };
                } else { // å·¦ãƒ•ãƒªãƒƒã‚¯
                    targetTile = { row: selectedTile.row, col: selectedTile.col - 1 };
                }
            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > swipeThreshold) { // å‚ç›´æ–¹å‘ã®ãƒ•ãƒªãƒƒã‚¯
                if (dy > 0) { // ä¸‹ãƒ•ãƒªãƒƒã‚¯
                    targetTile = { row: selectedTile.row + 1, col: selectedTile.col };
                } else { // ä¸Šãƒ•ãƒªãƒƒã‚¯
                    targetTile = { row: selectedTile.row - 1, col: selectedTile.col };
                }
            } else if (Math.abs(dx) <= swipeThreshold && Math.abs(dy) <= swipeThreshold && touchDuration < maxTapDuration) {
                // ç§»å‹•è·é›¢ãŒå°ã•ãã€æ™‚é–“ãŒçŸ­ã„å ´åˆã¯ã‚¿ãƒƒãƒ—ã¨ã¿ãªã™ (ã“ã“ã§ã¯ç‰¹ã«å‡¦ç†ãªã—ã€é¸æŠè§£é™¤ã®ã¿)
                selectedTile = null;
                drawBoard();
                return;
            }

            if (targetTile && isValidSwap(selectedTile, targetTile)) {
                isProcessing = true; // å‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹

                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ä¼´ã£ã¦ã‚¢ã‚¤ãƒ†ãƒ ã‚’å…¥ã‚Œæ›¿ãˆã‚‹
                await animateSwap(selectedTile, targetTile);

                // å…¥ã‚Œæ›¿ãˆå¾Œã®ãƒãƒƒãƒåˆ¤å®š
                const matches = findMatches();
                if (matches.length > 0) {
                    await processGameCycle(); // ãƒãƒƒãƒå‡¦ç†ã€è½ä¸‹ã€è£œå……ã€é€£é–
                } else {
                    // ãƒãƒƒãƒã—ãªã‹ã£ãŸã‚‰å…ƒã«æˆ»ã™ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    await animateSwap(targetTile, selectedTile); // å…ƒã«æˆ»ã™
                }
            } else {
                selectedTile = null; // ç„¡åŠ¹ãªã‚¹ãƒ¯ã‚¤ãƒ—ãªã‚‰é¸æŠè§£é™¤
            }
            selectedTile = null; // é¸æŠã‚’è§£é™¤
            drawBoard(); // æœ€çµ‚çš„ãªãƒœãƒ¼ãƒ‰çŠ¶æ…‹ã‚’æç”»
            isProcessing = false; // å‡¦ç†ä¸­ãƒ•ãƒ©ã‚°ã‚’è§£é™¤
        });

        /**
         * ã‚²ãƒ¼ãƒ ã®ã‚µã‚¤ã‚¯ãƒ« (ãƒãƒƒãƒå‡¦ç†ã€è½ä¸‹ã€è£œå……ã€é€£é–) ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
         */
        async function processGameCycle() {
            let matchesFound = true;
            while (matchesFound) {
                const matches = findMatches();
                if (matches.length > 0) {
                    await animateMatchRemoval(matches); // ãƒãƒƒãƒã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¶ˆå»ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    dropTiles(); // ã‚¢ã‚¤ãƒ†ãƒ ã‚’è½ä¸‹
                    await animateDrop(); // è½ä¸‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                    fillEmptyTiles(); // ç©ºã®ãƒã‚¹ã«æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã‚’è£œå……
                    await animateFill(); // è£œå……ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                } else {
                    matchesFound = false; // ãƒãƒƒãƒãŒãªã‘ã‚Œã°ãƒ«ãƒ¼ãƒ—çµ‚äº†
                }
            }
        }

        /**
         * 2ã¤ã®ã‚¿ã‚¤ãƒ«ãŒå…¥ã‚Œæ›¿ãˆå¯èƒ½ã‹åˆ¤å®šã—ã¾ã™ã€‚
         * @param {Object} tile1 - 1ã¤ç›®ã®ã‚¿ã‚¤ãƒ« {row, col}
         * @param {Object} tile2 - 2ã¤ç›®ã®ã‚¿ã‚¤ãƒ« {row, col}
         * @returns {boolean} - å…¥ã‚Œæ›¿ãˆå¯èƒ½ãªã‚‰true
         */
        function isValidSwap(tile1, tile2) {
            // ç›¤é¢å¤–ã‹ã©ã†ã‹ã®ãƒã‚§ãƒƒã‚¯
            if (tile2.row < 0 || tile2.row >= GRID_ROWS || tile2.col < 0 || tile2.col >= GRID_COLS) {
                return false;
            }
            // éš£æ¥ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹ã®ãƒã‚§ãƒƒã‚¯ (ç¸¦ã‹æ¨ªã«1ãƒã‚¹ã ã‘é›¢ã‚Œã¦ã„ã‚‹)
            const dr = Math.abs(tile1.row - tile2.row);
            const dc = Math.abs(tile1.col - tile2.col);
            return (dr === 1 && dc === 0) || (dr === 0 && dc === 1);
        }

        /**
         * ã‚¢ã‚¤ãƒ†ãƒ ã®å…¥ã‚Œæ›¿ãˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã€ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
         * @param {Object} tile1 - å…¥ã‚Œæ›¿ãˆã‚‹1ã¤ç›®ã®ã‚¿ã‚¤ãƒ« {row, col}
         * @param {Object} tile2 - å…¥ã‚Œæ›¿ãˆã‚‹2ã¤ç›®ã®ã‚¿ã‚¤ãƒ« {row, col}
         * @returns {Promise<void>} - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã«è§£æ±ºã™ã‚‹Promise
         */
        async function animateSwap(tile1, tile2) {
            const item1 = gameBoard[tile1.row][tile1.col];
            const item2 = gameBoard[tile2.row][tile2.col];

            // ä»®æƒ³çš„ãªä½ç½®æƒ…å ±ã‚’æŒã¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
            const animatedTiles = [
                { type: item1, x: tile1.col * TILE_SIZE, y: tile1.row * TILE_SIZE, targetX: tile2.col * TILE_SIZE, targetY: tile2.row * TILE_SIZE },
                { type: item2, x: tile2.col * TILE_SIZE, y: tile2.row * TILE_SIZE, targetX: tile1.col * TILE_SIZE, targetY: tile1.row * TILE_SIZE }
            ];

            const startTime = performance.now();

            return new Promise(resolve => {
                function animate() {
                    const elapsed = performance.now() - startTime;
                    const progress = Math.min(elapsed / SWAP_ANIMATION_DURATION, 1); // 0ã‹ã‚‰1ã«æ­£è¦åŒ–

                    drawBoard(); // èƒŒæ™¯ã®ãƒœãƒ¼ãƒ‰ã‚’ã¾ãšæç”» (é¸æŠãƒã‚¤ãƒ©ã‚¤ãƒˆãªã—)

                    animatedTiles.forEach(tile => {
                        ctx.fillStyle = '#f8f8f8'; // è–„ã„ã‚°ãƒ¬ãƒ¼ã®èƒŒæ™¯
                        ctx.fillRect(tile.col * TILE_SIZE, tile.row * TILE_SIZE, TILE_SIZE, TILE_SIZE); // å…ƒã®ä½ç½®ã«èƒŒæ™¯ã‚’æç”»

                        const currentX = tile.x + (tile.targetX - tile.x) * progress;
                        const currentY = tile.y + (tile.targetY - tile.y) * progress;
                        
                        ctx.font = `${TILE_SIZE * 0.7}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(fruitEmojis[tile.type], currentX + TILE_SIZE / 2, currentY + TILE_SIZE / 2);
                    });

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã€å®Ÿéš›ã®ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°
                        gameBoard[tile1.row][tile1.col] = item2;
                        gameBoard[tile2.row][tile2.col] = item1;
                        drawBoard(); // æœ€çµ‚çš„ãªçŠ¶æ…‹ã‚’æç”»
                        resolve();
                    }
                }
                requestAnimationFrame(animate);
            });
        }

        /**
         * ãƒãƒƒãƒã—ã¦ã„ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¤œå‡ºã—ã€ãã®åº§æ¨™ã®é…åˆ—ã‚’è¿”ã—ã¾ã™ã€‚
         * @returns {Array<Object>} - ãƒãƒƒãƒã—ãŸã‚¿ã‚¤ãƒ«ã® {row, col} ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
         */
        function findMatches() {
            const matches = new Set(); // é‡è¤‡ã‚’é¿ã‘ã‚‹ãŸã‚ã«Setã‚’ä½¿ç”¨

            // æ°´å¹³æ–¹å‘ã®ãƒãƒƒãƒã‚’æ¤œå‡º
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS - 2; c++) {
                    const item = gameBoard[r][c];
                    if (item !== null && item === gameBoard[r][c + 1] && item === gameBoard[r][c + 2]) {
                        // 3ã¤ä»¥ä¸Šä¸¦ã‚“ã§ã„ã‚‹å ´åˆ
                        let i = c;
                        while (i < GRID_COLS && gameBoard[r][i] === item) {
                            matches.add(JSON.stringify({ row: r, col: i }));
                            i++;
                        }
                    }
                }
            }

            // å‚ç›´æ–¹å‘ã®ãƒãƒƒãƒã‚’æ¤œå‡º
            for (let c = 0; c < GRID_COLS; c++) {
                for (let r = 0; r < GRID_ROWS - 2; r++) {
                    const item = gameBoard[r][c];
                    if (item !== null && item === gameBoard[r + 1][c] && item === gameBoard[r + 2][c]) {
                        let i = r;
                        while (i < GRID_ROWS && gameBoard[i][c] === item) {
                            matches.add(JSON.stringify({ row: i, col: c }));
                            i++;
                        }
                    }
                }
            }
            return Array.from(matches).map(s => JSON.parse(s));
        }

        /**
         * ãƒãƒƒãƒã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã‚’æ¶ˆå»ã™ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
         * @param {Array<Object>} matches - æ¶ˆå»ã™ã‚‹ã‚¿ã‚¤ãƒ«ã® {row, col} ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®é…åˆ—
         * @returns {Promise<void>} - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã«è§£æ±ºã™ã‚‹Promise
         */
        async function animateMatchRemoval(matches) {
            const startTime = performance.now();
            const tilesToRemove = matches.map(match => ({
                row: match.row,
                col: match.col,
                originalType: gameBoard[match.row][match.col] // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã«å…ƒã®ã‚¿ã‚¤ãƒ—ã‚’ä¿æŒ
            }));

            return new Promise(resolve => {
                function animate() {
                    const elapsed = performance.now() - startTime;
                    const progress = Math.min(elapsed / MATCH_FADE_DURATION, 1); // 0ã‹ã‚‰1ã«æ­£è¦åŒ–
                    const alpha = 1 - progress; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ

                    drawBoard(1); // å…¨ã¦ã®ã‚¿ã‚¤ãƒ«ã‚’é€šå¸¸æç”»

                    // æ¶ˆå»å¯¾è±¡ã®ã‚¿ã‚¤ãƒ«ã ã‘é€æ˜åº¦ã‚’ä¸‹ã’ã¦æç”»
                    tilesToRemove.forEach(tile => {
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = '#f8f8f8'; // è–„ã„ã‚°ãƒ¬ãƒ¼ã®èƒŒæ™¯
                        ctx.fillRect(tile.col * TILE_SIZE, tile.row * TILE_SIZE, TILE_SIZE, TILE_SIZE); // èƒŒæ™¯ã‚’æç”»
                        ctx.font = `${TILE_SIZE * 0.7}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(fruitEmojis[tile.originalType], tile.col * TILE_SIZE + TILE_SIZE / 2, tile.row * TILE_SIZE + TILE_SIZE / 2);
                        ctx.globalAlpha = 1;
                    });

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ‚äº†å¾Œã€ãƒœãƒ¼ãƒ‰ã‹ã‚‰ã‚¢ã‚¤ãƒ†ãƒ ã‚’å‰Šé™¤
                        matches.forEach(match => {
                            gameBoard[match.row][match.col] = null;
                        });
                        drawBoard(); // æœ€çµ‚çš„ãªçŠ¶æ…‹ã‚’æç”»
                        resolve();
                    }
                }
                requestAnimationFrame(animate);
            });
        }

        /**
         * ã‚¢ã‚¤ãƒ†ãƒ ã‚’è½ä¸‹ã•ã›ã€ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
         */
        function dropTiles() {
            for (let c = 0; c < GRID_COLS; c++) {
                let emptySpaces = 0; // ãã®åˆ—ã®ç©ºããƒã‚¹ã®æ•°
                for (let r = GRID_ROWS - 1; r >= 0; r--) {
                    if (gameBoard[r][c] === null) {
                        emptySpaces++;
                    } else if (emptySpaces > 0) {
                        // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç©ºããƒã‚¹ã®æ•°ã ã‘ä¸‹ã«ç§»å‹•
                        gameBoard[r + emptySpaces][c] = gameBoard[r][c];
                        gameBoard[r][c] = null;
                    }
                }
            }
        }

        /**
         * ã‚¢ã‚¤ãƒ†ãƒ è½ä¸‹ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
         * (å®Ÿéš›ã«ã¯dropTiles()ã§çŠ¶æ…‹ãŒæ›´æ–°ã•ã‚ŒãŸå¾Œã«ã€ãã®å¤‰åŒ–ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§è¡¨ç¾)
         * @returns {Promise<void>} - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã«è§£æ±ºã™ã‚‹Promise
         */
        async function animateDrop() {
            // ã“ã®é–¢æ•°ã¯ã€dropTiles()ã«ã‚ˆã£ã¦æ›´æ–°ã•ã‚ŒãŸãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’å…ƒã«ã€
            // å®Ÿéš›ã«ã‚¿ã‚¤ãƒ«ãŒè½ã¡ã‚‹ã‚ˆã†ã«è¦‹ã›ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
            // ç°¡ç•¥åŒ–ã®ãŸã‚ã€ã“ã“ã§ã¯å˜ç´”ã«setTimeoutã§å¾…ã¤ã ã‘ã«ã—ã¾ã™ã€‚
            // ã‚ˆã‚Šé«˜åº¦ãªå®Ÿè£…ã§ã¯ã€å„ã‚¿ã‚¤ãƒ«ã®é–‹å§‹Yåº§æ¨™ã¨çµ‚äº†Yåº§æ¨™ã‚’è¨ˆç®—ã—ã€
            // requestAnimationFrameã§è£œé–“ã—ã¦æç”»ã—ã¾ã™ã€‚
            drawBoard(); // è½ä¸‹å¾Œã®çŠ¶æ…‹ã‚’å³æ™‚æç”» (ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—)
            return new Promise(resolve => setTimeout(resolve, DROP_ANIMATION_DURATION));
        }

        /**
         * ç©ºã®ãƒã‚¹ã«æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ ã‚’è£œå……ã—ã€ãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’æ›´æ–°ã—ã¾ã™ã€‚
         */
        function fillEmptyTiles() {
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (gameBoard[r][c] === null) {
                        gameBoard[r][c] = Math.floor(Math.random() * ITEM_TYPES);
                    }
                }
            }
        }

        /**
         * æ–°ã—ã„ã‚¢ã‚¤ãƒ†ãƒ è£œå……ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
         * (å®Ÿéš›ã«ã¯fillEmptyTiles()ã§çŠ¶æ…‹ãŒæ›´æ–°ã•ã‚ŒãŸå¾Œã«ã€ãã®å¤‰åŒ–ã‚’ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã§è¡¨ç¾)
         * @returns {Promise<void>} - ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³å®Œäº†æ™‚ã«è§£æ±ºã™ã‚‹Promise
         */
        async function animateFill() {
            // ã“ã®é–¢æ•°ã¯ã€fillEmptyTiles()ã«ã‚ˆã£ã¦æ›´æ–°ã•ã‚ŒãŸãƒœãƒ¼ãƒ‰ã®çŠ¶æ…‹ã‚’å…ƒã«ã€
            // æ–°ã—ã„ã‚¿ã‚¤ãƒ«ãŒä¸Šã‹ã‚‰é™ã£ã¦ãã‚‹ã‚ˆã†ã«è¦‹ã›ã‚‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
            // ç°¡ç•¥åŒ–ã®ãŸã‚ã€ã“ã“ã§ã¯å˜ç´”ã«setTimeoutã§å¾…ã¤ã ã‘ã«ã—ã¾ã™ã€‚
            drawBoard(); // è£œå……å¾Œã®çŠ¶æ…‹ã‚’å³æ™‚æç”» (ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãªã—)
            return new Promise(resolve => setTimeout(resolve, 200)); // å°‘ã—å¾…ã¤
        }

        // --- ã‚²ãƒ¼ãƒ ã®åˆæœŸè¨­å®šã¨é–‹å§‹ ---
        // Canvasã®ã‚µã‚¤ã‚ºã‚’åˆæœŸè¨­å®š
        calculateCanvasSize();
        initBoard(); // ç”»åƒãƒ­ãƒ¼ãƒ‰ã¯ä¸è¦ã«ãªã£ãŸãŸã‚ã€ç›´æ¥ãƒœãƒ¼ãƒ‰ã‚’åˆæœŸåŒ–

        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ãƒªã‚µã‚¤ã‚ºã‚¤ãƒ™ãƒ³ãƒˆã«å¯¾å¿œ (Canvasã‚µã‚¤ã‚ºã‚’å†è¨­å®šã—ã€å†æç”»)
        window.addEventListener('resize', () => {
            calculateCanvasSize(); // ã‚µã‚¤ã‚ºã‚’å†è¨ˆç®—
            drawBoard(); // å†æç”»
        });

        // ãƒã‚¦ã‚¹ã‚¤ãƒ™ãƒ³ãƒˆã‚‚è¿½åŠ  (ãƒ‡ãƒãƒƒã‚°ç”¨ã‚„PCã§ã®æ“ä½œç”¨)
        let mouseStartX, mouseStartY;
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (isProcessing) return;

            mouseStartX = e.clientX;
            mouseStartY = e.clientY;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const col = Math.floor(x / TILE_SIZE);
            const row = Math.floor(y / TILE_SIZE);

            if (row >= 0 && row < GRID_ROWS && col >= 0 && col < GRID_COLS) {
                selectedTile = { row, col };
                drawBoard();
            }
        });

        canvas.addEventListener('mouseup', async (e) => {
            if (!selectedTile || isProcessing) return;

            const dx = e.clientX - mouseStartX;
            const dy = e.clientY - mouseStartY;

            const swipeThreshold = TILE_SIZE * 0.5; // ãƒ•ãƒªãƒƒã‚¯ã¨åˆ¤å®šã™ã‚‹æœ€å°ç§»å‹•è·é›¢ (ã‚¿ã‚¤ãƒ«ã®åŠåˆ†)

            let targetTile = null;

            if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > swipeThreshold) {
                if (dx > 0) {
                    targetTile = { row: selectedTile.row, col: selectedTile.col + 1 };
                } else {
                    targetTile = { row: selectedTile.row, col: selectedTile.col - 1 };
                }
            } else if (Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > swipeThreshold) {
                if (dy > 0) {
                    targetTile = { row: selectedTile.row + 1, col: selectedTile.col };
                } else {
                    targetTile = { row: selectedTile.row - 1, col: selectedTile.col };
                }
            }

            if (targetTile && isValidSwap(selectedTile, targetTile)) {
                isProcessing = true;
                await animateSwap(selectedTile, targetTile);

                const matches = findMatches();
                if (matches.length > 0) {
                    await processGameCycle();
                } else {
                    await animateSwap(targetTile, selectedTile);
                }
            } else {
                selectedTile = null;
            }
            selectedTile = null;
            drawBoard();
            isProcessing = false;
        });

    </script>
</body>
</html>
